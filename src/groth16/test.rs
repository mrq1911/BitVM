use crate::execute_script_without_stack_limit;
use crate::groth16::verifier::Verifier;
use ark_bn254::{Bn254, Fq, Fr, G1Affine, G2Affine};
use ark_crypto_primitives::snark::{CircuitSpecificSetupSNARK, SNARK};
use ark_ec::pairing::Pairing;
use ark_ff::{BigInt, PrimeField, QuadExtField};
use ark_groth16::{prepare_verifying_key, Groth16, Proof, VerifyingKey};
use ark_relations::lc;
use ark_relations::r1cs::{ConstraintSynthesizer, ConstraintSystemRef, SynthesisError};
use ark_std::{end_timer, start_timer, test_rng, UniformRand};
use rand::{RngCore, SeedableRng};

type GrothBn = Groth16<Bn254>;

#[derive(Copy)]
struct DummyCircuit<F: PrimeField> {
    pub a: Option<F>,
    pub b: Option<F>,
    pub num_variables: usize,
    pub num_constraints: usize,
}

impl<F: PrimeField> Clone for DummyCircuit<F> {
    fn clone(&self) -> Self {
        DummyCircuit {
            a: self.a.clone(),
            b: self.b.clone(),
            num_variables: self.num_variables.clone(),
            num_constraints: self.num_constraints.clone(),
        }
    }
}

impl<F: PrimeField> ConstraintSynthesizer<F> for DummyCircuit<F> {
    fn generate_constraints(self, cs: ConstraintSystemRef<F>) -> Result<(), SynthesisError> {
        let a = cs.new_witness_variable(|| self.a.ok_or(SynthesisError::AssignmentMissing))?;
        let b = cs.new_witness_variable(|| self.b.ok_or(SynthesisError::AssignmentMissing))?;
        let c = cs.new_input_variable(|| {
            let a = self.a.ok_or(SynthesisError::AssignmentMissing)?;
            let b = self.b.ok_or(SynthesisError::AssignmentMissing)?;

            Ok(a * b)
        })?;

        for _ in 0..(self.num_variables - 3) {
            let _ = cs.new_witness_variable(|| self.a.ok_or(SynthesisError::AssignmentMissing))?;
        }

        for _ in 0..self.num_constraints - 1 {
            cs.enforce_constraint(lc!() + a, lc!() + b, lc!() + c)?;
        }

        cs.enforce_constraint(lc!(), lc!(), lc!())?;

        Ok(())
    }
}

#[test]
fn test_groth16_verifier() {
    type E = Bn254;
    let k = 6;
    let mut rng = ark_std::rand::rngs::StdRng::seed_from_u64(test_rng().next_u64());
    let circuit = DummyCircuit::<<E as Pairing>::ScalarField> {
        a: Some(<E as Pairing>::ScalarField::rand(&mut rng)),
        b: Some(<E as Pairing>::ScalarField::rand(&mut rng)),
        num_variables: 10,
        num_constraints: 1 << k,
    };
    let (pk, vk) = Groth16::<E>::setup(circuit, &mut rng).unwrap();
    let pvk = prepare_verifying_key::<E>(&vk);

    let c = circuit.a.unwrap() * circuit.b.unwrap();

    let proof = Groth16::<E>::prove(&pk, circuit, &mut rng).unwrap();
    println!("proof = {:?}", proof);
    println!("vk = {:?}", vk);
    println!("input = {:?}", c.clone());
    assert!(Groth16::<E>::verify_with_processed_vk(&pvk, &[c], &proof).unwrap());

    let start = start_timer!(|| "collect_script");
    let script = Verifier::verify_proof(&vec![c], &proof, &vk);
    end_timer!(start);

    println!("groth16::test_verify_proof = {} bytes", script.len());

    let start = start_timer!(|| "execute_script");
    let exec_result = execute_script_without_stack_limit(script);
    end_timer!(start);

    assert!(exec_result.success);
}

/*
one sample proof generated by arkworks circom https://github.com/arkworks-rs/circom-compat/blob/b892c62597687c23341cda1e8e89d58bb6428f36/tests/groth16.rs#L12

proof = Proof { a: (1880657916796204156029607496232531106290158286507251501327029473637446343187, 11373946357139183619064986011739169948493473077497088526168256624412250824261), b: (QuadExtField(14115545539685451214132929516606978035613438950189118240396153325944285287070 + 5465087942617801631110187139473902334543323287145525241048627386728063074242 * u), QuadExtField(2358587840605830269221908436088125961251170719464654854520611980502672600359 + 1567184035974604909392126071679411055964810862758295588793018201850110630110 * u)), c: (14613806490157823821299814816327409554520317564389972689212628382680141724905, 8631550201208323750094900350281914640694959431397211082960552457966717575557) }
vk = VerifyingKey { alpha_g1: (5932351381898971266356899568821211884831332181613997633025979788231929741851, 6268463107272969643674689035147808262110651675282230417040477349705376988335), beta_g2: (QuadExtField(14348917533204783332134271515499236162754014179136221738501263983865206926577 + 8447759603081430025941906165310200407347800085018620796430666861916758910797 * u), QuadExtField(4577598762028678986432203877201311177943867921220866356238438833328119393068 + 21595522683136432931842406086191278718982002956870227320927471487925519007769 * u)), gamma_g2: (QuadExtField(12758731989587038843936993873200617501131838609259667218149243986519809067170 + 14242552006783303065228214782967679157252319512372647577145354168816354787784 * u), QuadExtField(15619856835278627957832221226048258871106737238884526672366890790296027368985 + 2633369012011343652362322095618077487903801311554702787016248634318905335467 * u)), delta_g2: (QuadExtField(14483010306839781593815186352264913665962077859110134924308236077389526595254 + 14833880185892702417589056623170779930127301663803657369552929192222213505906 * u), QuadExtField(6268171286003761105092277111088101362785387080673605062189745814633353103238 + 19004699832092828311808425082279526129749489359287930477314526915838906178423 * u)), gamma_abc_g1: [(6526167261158232449630936230574416495109601480492387695755889769729127053363, 7021385830649716611908155151593965393582085080329129177403566597675378714428), (14464298986163031703330916524648977496322390754738197164211595898704703835256, 8411827833229969598806288717779733860507191815220538550152497231733452151775)] }
inputs = [BigInt([33, 0, 0, 0])]

try to verify it using bitvm
*/
#[test]
fn test_mohammed_proof() {
    let a = G1Affine::new(
        Fq::new(BigInt!("1880657916796204156029607496232531106290158286507251501327029473637446343187")),
        Fq::new(BigInt!("11373946357139183619064986011739169948493473077497088526168256624412250824261"))
    );
    let b = G2Affine::new(
        QuadExtField::new(
            Fq::new(BigInt!("14115545539685451214132929516606978035613438950189118240396153325944285287070")),
            Fq::new(BigInt!("5465087942617801631110187139473902334543323287145525241048627386728063074242"))
        ),
        QuadExtField::new(
            Fq::new(BigInt!("2358587840605830269221908436088125961251170719464654854520611980502672600359")),
            Fq::new(BigInt!("1567184035974604909392126071679411055964810862758295588793018201850110630110"))
        ),
    );
    let c = G1Affine::new(
        Fq::new(BigInt!("14613806490157823821299814816327409554520317564389972689212628382680141724905")),
        Fq::new(BigInt!("8631550201208323750094900350281914640694959431397211082960552457966717575557"))
    );

    let proof = Proof::<Bn254> { a, b, c};

    let vk = VerifyingKey::<Bn254> {
        alpha_g1: G1Affine::new(
            Fq::new(BigInt!("5932351381898971266356899568821211884831332181613997633025979788231929741851")),
            Fq::new(BigInt!("6268463107272969643674689035147808262110651675282230417040477349705376988335"))
        ),
        beta_g2: G2Affine::new(
            QuadExtField::new(
                Fq::new(BigInt!("14348917533204783332134271515499236162754014179136221738501263983865206926577")),
                Fq::new(BigInt!("8447759603081430025941906165310200407347800085018620796430666861916758910797"))
            ),
            QuadExtField::new(
                Fq::new(BigInt!("4577598762028678986432203877201311177943867921220866356238438833328119393068")),
                Fq::new(BigInt!("21595522683136432931842406086191278718982002956870227320927471487925519007769"))
            ),
        ),
        gamma_g2: G2Affine::new(
            QuadExtField::new(
                Fq::new(BigInt!("12758731989587038843936993873200617501131838609259667218149243986519809067170")),
                Fq::new(BigInt!("14242552006783303065228214782967679157252319512372647577145354168816354787784"))
            ),
            QuadExtField::new(
                Fq::new(BigInt!("15619856835278627957832221226048258871106737238884526672366890790296027368985")),
                Fq::new(BigInt!("2633369012011343652362322095618077487903801311554702787016248634318905335467"))
            ),
        ),
        delta_g2: G2Affine::new(
            QuadExtField::new(
                Fq::new(BigInt!("14483010306839781593815186352264913665962077859110134924308236077389526595254")),
                Fq::new(BigInt!("14833880185892702417589056623170779930127301663803657369552929192222213505906"))
            ),
            QuadExtField::new(
                Fq::new(BigInt!("6268171286003761105092277111088101362785387080673605062189745814633353103238")),
                Fq::new(BigInt!("19004699832092828311808425082279526129749489359287930477314526915838906178423"))
            ),
        ),
        gamma_abc_g1: vec![
            G1Affine::new(
                Fq::new(BigInt!("6526167261158232449630936230574416495109601480492387695755889769729127053363")),
                Fq::new(BigInt!("7021385830649716611908155151593965393582085080329129177403566597675378714428"))
            ),
            G1Affine::new(
                Fq::new(BigInt!("14464298986163031703330916524648977496322390754738197164211595898704703835256")),
                Fq::new(BigInt!("8411827833229969598806288717779733860507191815220538550152497231733452151775"))
            )
        ],
    };

    let input = BigInt!("33");

    println!("proof = {:?}", proof);
    println!("vk = {:?}", vk);
    println!("input = {:?}", input);

    // check if proof can be verified by ark groth16 impl
    let pvk = GrothBn::process_vk(&vk).unwrap();
    let res = GrothBn::verify_proof(&pvk, &proof, &vec![input.into()]);

    println!("ark groth16 results = {:?}", res);

    // check if we can generate BitVM script to verify the proof
    let start = start_timer!(|| "collect_script");
    let script = Verifier::verify_proof(&vec![input.into()], &proof, &vk);
    end_timer!(start);

    println!("groth16::test_verify_proof = {} bytes", script.len());

    let start = start_timer!(|| "execute_script");
    let exec_result = execute_script_without_stack_limit(script);
    end_timer!(start);

    assert!(exec_result.success);
}
